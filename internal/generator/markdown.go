package generator

import (
	"context"
	"docod/internal/knowledge"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"unicode"
)

// MarkdownGenerator produces documentation in Markdown format.
type MarkdownGenerator struct {
	engine     *knowledge.Engine
	summarizer knowledge.Summarizer
	mermaid    *MermaidGenerator
}

func NewMarkdownGenerator(e *knowledge.Engine, s knowledge.Summarizer) *MarkdownGenerator {
	return &MarkdownGenerator{
		engine:     e,
		summarizer: s,
		mermaid:    &MermaidGenerator{},
	}
}

// GenerateDocs iterates through the graph and creates a single comprehensive documentation file.
func (g *MarkdownGenerator) GenerateDocs(ctx context.Context, outputDir string) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	path := filepath.Join(outputDir, "documentation.md")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	// 1. Title & Header
	fmt.Fprintln(f, "# Project Documentation")
	fmt.Fprintln(f, "\nAuto-generated by `docod`.\n")

	// 2. Smart Context Selection (RAG)
	fmt.Println("üîç Selecting relevant context using Vector Search...")
	
	uniqueChunks := make(map[string]knowledge.SearchChunk) // ID -> Chunk (Deduplication)
	
	// Query 1: Architecture & Core Concepts
	archChunks, _ := g.engine.SearchByText(ctx, "project architecture purpose design philosophy system overview high level structure", 20, "")
	for _, c := range archChunks { uniqueChunks[c.ID] = c }

	// Query 2: Key Features & Business Logic
	featChunks, _ := g.engine.SearchByText(ctx, "core business logic key features domain services main functionality", 25, "")
	for _, c := range featChunks { uniqueChunks[c.ID] = c }

	// Query 3: Configuration & Entry Points
	confChunks, _ := g.engine.SearchByText(ctx, "configuration setup main entry point environment variables build instructions", 10, "")
	for _, c := range confChunks { uniqueChunks[c.ID] = c }

	// Fallback mechanism: If search returns nothing (e.g. embedding failed or small project)
	var archList, featList, confList []knowledge.SearchChunk
	
	if len(uniqueChunks) == 0 {
		fmt.Println("‚ö†Ô∏è  Search yielded no results. Using intelligent fallback selection.")
		allChunks := g.engine.PrepareSearchChunks()
		
		// Intelligent filtering for fallback
		var fallbackChunks []knowledge.SearchChunk
		for _, c := range allChunks {
			name := strings.ToLower(c.Name)
			if strings.Contains(name, "main") || 
			   strings.Contains(name, "config") || 
			   strings.Contains(name, "service") || 
			   strings.Contains(name, "handler") || 
			   strings.Contains(name, "model") ||
			   strings.Contains(name, "core") {
				fallbackChunks = append(fallbackChunks, c)
			}
		}
		// Safety net: if filtering leaves too few, take top 20
		if len(fallbackChunks) < 5 && len(allChunks) > 0 {
			limit := 20
			if len(allChunks) < 20 { limit = len(allChunks) }
			fallbackChunks = allChunks[:limit]
		}
		
		// Distribute same fallback chunks to all contexts to ensure coverage
		archList = fallbackChunks
		featList = fallbackChunks
		confList = fallbackChunks
	} else {
		// Convert map back to slices for specific sections if we want to maintain separation,
		// BUT PromptBuilder expects specific slices.
		// Since we merged them into uniqueChunks to deduplicate globally, we might lose per-section specificity.
		// However, for One-Shot prompting, passing the *union* of relevant chunks to all sections 
		// (or specific subsets if we tracked them) is valid.
		// To keep it simple and context-rich, let's just use the specific search results directly 
		// but apply a global deduplication check if needed.
		// Actually, passing specific results to specific prompt sections is better for steering the LLM.
		// So let's NOT merge into uniqueChunks for passing to LLM, but use the specific search results.
		// The uniqueChunks map was just to check if we found *anything*.
		
		archList = archChunks
		featList = featChunks
		confList = confChunks
		
		fmt.Printf("üìâ Context Optimization: Arch(%d), Feat(%d), Conf(%d)\n", len(archList), len(featList), len(confList))
	}

	// 3. One-Shot Full Documentation Generation
	fmt.Println("üåü Generating Full Documentation (One-Shot)...")
	
	fullDoc, err := g.summarizer.SummarizeFullDoc(ctx, archList, featList, confList)
	if err != nil {
		return fmt.Errorf("failed to generate documentation: %w", err)
	}
	fmt.Fprintf(f, "%s\n", fullDoc)

	// 4. Append Deterministic Config Table (Accuracy Guarantee)
	// We use the full set for this to ensure we don't miss any constants
	g.generateConfigTable(f, g.engine.PrepareSearchChunks())

	return nil
}

func (g *MarkdownGenerator) generateConfigTable(f *os.File, units []knowledge.SearchChunk) {
	var configs []knowledge.SearchChunk
	for _, u := range units {
		if u.UnitType == "constant" || u.UnitType == "variable" {
			configs = append(configs, u)
		}
	}

	if len(configs) == 0 {
		return
	}

	fmt.Fprintln(f, "\n# Configuration Reference")
	fmt.Fprintln(f, "| Name | Value | Description |")
	fmt.Fprintln(f, "| :--- | :--- | :--- |")

	for _, c := range configs {
		value := "-"
		parts := strings.SplitN(c.Signature, "=", 2)
		if len(parts) == 2 {
			value = strings.TrimSpace(parts[1])
		}
		desc := strings.ReplaceAll(c.Description, "\n", " ")
		fmt.Fprintf(f, "| `%s` | `%s` | %s |\n", c.Name, value, desc)
	}
	fmt.Fprintln(f, "")
}

func isExported(name string) bool {
	if name == "" {
		return false
	}
	first := rune(name[0])
	return unicode.IsUpper(first)
}