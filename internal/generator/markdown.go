package generator

import (
	"context"
	"docod/internal/knowledge"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// MarkdownGenerator produces documentation in Markdown format.
type MarkdownGenerator struct {
	engine     *knowledge.Engine
	summarizer knowledge.Summarizer
	mermaid    *MermaidGenerator
}

func NewMarkdownGenerator(e *knowledge.Engine, s knowledge.Summarizer) *MarkdownGenerator {
	return &MarkdownGenerator{
		engine:     e,
		summarizer: s,
		mermaid:    &MermaidGenerator{},
	}
}

// GenerateDocs iterates through the graph and creates a single comprehensive documentation file.
func (g *MarkdownGenerator) GenerateDocs(ctx context.Context, outputDir string) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	path := filepath.Join(outputDir, "documentation.md")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	chunks := g.engine.PrepareSearchChunks()

	// 1. Table of Contents
	fmt.Fprintln(f, "# Project Documentation")
	fmt.Fprintln(f, "\nAuto-generated by `docod`.\n")
	fmt.Fprintln(f, "## Table of Contents")
	fmt.Fprintln(f, "- [Architecture & Core Concepts](#architecture--core-concepts)")
	fmt.Fprintln(f, "- [Key Features & Onboarding](#key-features--onboarding)")
	fmt.Fprintln(f, "- [Development](#development)")

	// 2. Architecture & Core Concepts (Merged Overview)
	fmt.Println("üåü Generating Architecture Overview...")
	fmt.Fprintln(f, "\n## Architecture & Core Concepts")
	
	// Intent-based retrieval for high-level architecture
	overviewContext, _ := g.engine.SearchByText(ctx, "project architecture purpose design philosophy system overview", 15, "")
	if len(overviewContext) == 0 {
		overviewContext = chunks
	}
	projectSummary, _ := g.summarizer.SummarizeProject(ctx, overviewContext)
	fmt.Fprintf(f, "\n%s\n\n", projectSummary)
	
	// System Flow Chart
	fmt.Fprintln(f, "### System Flow")
	fmt.Fprintln(f, g.mermaid.GenerateFlowChart(chunks))

	// 3. Key Features & Onboarding
	fmt.Println("‚ú® Generating Key Features & Onboarding...")
	fmt.Fprintln(f, "\n## Key Features & Onboarding")
	
	featureContext, _ := g.engine.SearchByText(ctx, "core business logic features user guide usage examples", 20, "")
	features, _ := g.summarizer.SummarizeFeatures(ctx, featureContext)
	fmt.Fprintf(f, "\n%s\n", features)

	g.generateGettingStarted(ctx, f)

	// 4. Development (Building, Testing, Config)
	fmt.Println("üõ†Ô∏è Generating Development Guide...")
	fmt.Fprintln(f, "\n## Development")
	
	// Config Table
	g.generateConfigTable(f, chunks)

	// Core Modules Deep Dive (Simplified)
	fmt.Fprintln(f, "\n### Core Modules")
	
	// Filter for only significant file modules
	var modules []knowledge.SearchChunk
	for _, c := range chunks {
		// Only include file modules that are likely core logic (heuristic)
		if c.UnitType == "file_module" && !strings.Contains(c.Name, "test") && !strings.Contains(c.Name, "util") {
			modules = append(modules, c)
		}
	}
	
	// Sort modules
	sort.Slice(modules, func(i, j int) bool {
		return modules[i].Name < modules[j].Name
	})

	for _, mod := range modules {
		fmt.Printf("  - Summarizing module: %s\n", mod.Name)
		fmt.Fprintf(f, "\n#### Module: `%s`\n", mod.Name)
		
		// Use vector search to find related context for this module
		relatedContext, _ := g.engine.SearchRelated(ctx, mod, 3)
		
		analysis, _ := g.summarizer.SummarizeUnit(ctx, mod, "", relatedContext) // CodeBody omitted for token saving, description has enough info
		fmt.Fprintf(f, "%s\n", analysis)
	}

	return nil
}

func (g *MarkdownGenerator) generateGettingStarted(ctx context.Context, f *os.File) {
	fmt.Fprintln(f, "\n## Getting Started")
	// Intent-based retrieval for setup context
	setupContext, _ := g.engine.SearchByText(ctx, "configuration setup main entry point installation guide env variables build run", 10, "")
	guide, _ := g.summarizer.SummarizeGettingStarted(ctx, setupContext)
	fmt.Fprintf(f, "\n### Quick Start\n\n%s\n", guide)
}

func (g *MarkdownGenerator) generateFeatureList(ctx context.Context, f *os.File) {
	fmt.Fprintln(f, "\n## Key Features")
	// Intent-based retrieval for feature context
	featureContext, _ := g.engine.SearchByText(ctx, "core business logic primary features high level architecture use cases", 15, "")
	features, _ := g.summarizer.SummarizeFeatures(ctx, featureContext)
	fmt.Fprintf(f, "\n%s\n", features)
}

func (g *MarkdownGenerator) generateConfigTable(f *os.File, units []knowledge.SearchChunk) {
	var configs []knowledge.SearchChunk
	for _, u := range units {
		if u.UnitType == "constant" || u.UnitType == "variable" {
			configs = append(configs, u)
		}
	}

	if len(configs) == 0 {
		return
	}

	fmt.Fprintln(f, "\n#### ‚öôÔ∏è Constants & Variables")
	fmt.Fprintln(f, "| Name | Type | Value | Description |")
	fmt.Fprintln(f, "| :--- | :--- | :--- | :--- |")

	for _, c := range configs {
		value := "-"
		parts := strings.SplitN(c.Signature, "=", 2)
		if len(parts) == 2 {
			value = strings.TrimSpace(parts[1])
		}
		desc := strings.ReplaceAll(c.Description, "\n", " ")
		fmt.Fprintf(f, "| `%s` | `%s` | `%s` | %s |\n", c.Name, c.UnitType, value, desc)
	}
	fmt.Fprintln(f, "")
}

func isExported(name string) bool {
	if name == "" {
		return false
	}
	first := rune(name[0])
	return unicode.IsUpper(first)
}