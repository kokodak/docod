package generator

import (
	"context"
	"docod/internal/knowledge"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// MarkdownGenerator produces documentation in Markdown format.
type MarkdownGenerator struct {
	engine     *knowledge.Engine
	summarizer knowledge.Summarizer
}

func NewMarkdownGenerator(e *knowledge.Engine, s knowledge.Summarizer) *MarkdownGenerator {
	return &MarkdownGenerator{
		engine:     e,
		summarizer: s,
	}
}

// GenerateDocs iterates through the graph and creates a single comprehensive documentation file.
func (g *MarkdownGenerator) GenerateDocs(ctx context.Context, outputDir string) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	path := filepath.Join(outputDir, "documentation.md")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintln(f, "# Project Documentation")
	fmt.Fprintln(f, "\nAuto-generated by `docod` - Sync your docs as fast as you ship your code.\n")

	// Group by package
	pkgGroups := make(map[string][]knowledge.SearchChunk)
	chunks := g.engine.PrepareSearchChunks()
	for _, chunk := range chunks {
		pkgGroups[chunk.Package] = append(pkgGroups[chunk.Package], chunk)
	}

	// Sort packages for deterministic output
	var pkgs []string
	for p := range pkgGroups {
		pkgs = append(pkgs, p)
	}
	sort.Strings(pkgs)

	for _, pkg := range pkgs {
		fmt.Fprintf(f, "## Package `%s`\n\n", pkg)
		
		units := pkgGroups[pkg]
		sort.Slice(units, func(i, j int) bool {
			return units[i].Name < units[j].Name
		})

		for _, unit := range units {
			fmt.Fprintf(f, "### %s `%s`\n\n", unit.Name, unit.UnitType)
			
			// 1. Gather actual dependency definitions for context
			var contextUnits []knowledge.SearchChunk
			for _, depID := range g.resolveDependencyIDs(unit) {
				if depChunk, ok := g.engine.GetChunkByID(depID); ok {
					contextUnits = append(contextUnits, depChunk)
				}
			}
			
			// 2. AI Interpretation (Deep Analysis)
			fmt.Printf("  - Generating deep analysis for %s...\n", unit.Name)
			analysis, err := g.summarizer.Summarize(ctx, unit, contextUnits)
			if err != nil {
				analysis = unit.Description
			}
			
			fmt.Fprintf(f, "%s\n\n", analysis)
			fmt.Fprintf(f, "#### Signature\n```go\n%s\n```\n\n", unit.Signature)
			
			if len(unit.Dependencies) > 0 {
				fmt.Fprintf(f, "**Dependencies**: %s  \n", strings.Join(unit.Dependencies, ", "))
			}
			if len(unit.UsedBy) > 0 {
				fmt.Fprintf(f, "**Architectural Role**: Used by %s  \n", strings.Join(unit.UsedBy, ", "))
			}
			fmt.Fprintln(f, "\n---")
		}
	}

	return nil
}

func (g *MarkdownGenerator) resolveDependencyIDs(unit knowledge.SearchChunk) []string {
	// This is a bit of a bridge between knowledge chunks and the graph
	// Ideally we'd store IDs in the relations, but for now we search by name in the engine's graph
	// (Simplified for this iteration)
	return nil 
}