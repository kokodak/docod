package generator

import (
	"context"
	"docod/internal/knowledge"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"
)

// MarkdownGenerator produces documentation in Markdown format.
type MarkdownGenerator struct {
	engine     *knowledge.Engine
	summarizer knowledge.Summarizer
	mermaid    *MermaidGenerator
}

func NewMarkdownGenerator(e *knowledge.Engine, s knowledge.Summarizer) *MarkdownGenerator {
	return &MarkdownGenerator{
		engine:     e,
		summarizer: s,
		mermaid:    &MermaidGenerator{},
	}
}

func (g *MarkdownGenerator) GenerateDocs(ctx context.Context, outputDir string) error {
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return err
	}

	path := filepath.Join(outputDir, "documentation.md")
	f, err := os.Create(path)
	if err != nil {
		return err
	}
	defer f.Close()

	chunks := g.engine.PrepareSearchChunks()

	// 1. Table of Contents
	fmt.Fprintln(f, "# Project Documentation")
	fmt.Fprintln(f, "\nAuto-generated by `docod`.\n")
	fmt.Fprintln(f, "## Table of Contents")
	fmt.Fprintln(f, "- [Project Overview](#project-overview)")
	fmt.Fprintln(f, "- [Getting Started](#getting-started)")
	fmt.Fprintln(f, "- [Key Features](#key-features)")
	fmt.Fprintln(f, "- [Architecture](#architecture-by-package)")

	// 2. Project Overview (Intent-Based Retrieval)
	fmt.Println("üåü Generating Project Overview...")
	fmt.Fprintln(f, "\n## Project Overview")
	
	// Retrieve chunks related to high-level architecture
	overviewContext, _ := g.engine.SearchByText(ctx, "project architecture purpose design philosophy system overview main entry point", 10, "")
	if len(overviewContext) == 0 {
		overviewContext = chunks // Fallback to all chunks if search fails or index empty
	}
	
	projectSummary, _ := g.summarizer.SummarizeProject(ctx, overviewContext)
	fmt.Fprintf(f, "\n%s\n\n", projectSummary)
	
	// Mermaid Flowchart
	fmt.Fprintln(f, "### System Flow")
	fmt.Fprintln(f, g.mermaid.GenerateFlowChart(chunks))

	// 3. Getting Started (Intent-Based Retrieval)
	fmt.Println("üöÄ Generating Getting Started Guide...")
	g.generateGettingStarted(ctx, f)

	// 4. Key Features (Intent-Based Retrieval)
	fmt.Println("‚ú® Generating Feature List...")
	g.generateFeatureList(ctx, f)

	// Group and Sort Packages
	pkgGroups := make(map[string][]knowledge.SearchChunk)
	for _, chunk := range chunks {
		if isExported(chunk.Name) {
			pkgGroups[chunk.Package] = append(pkgGroups[chunk.Package], chunk)
		}
	}
	var pkgs []string
	for p := range pkgGroups {
		pkgs = append(pkgs, p)
	}
	sort.Strings(pkgs)

	// 5. Package Architecture
	fmt.Fprintln(f, "\n## Architecture by Package")
	for _, pkg := range pkgs {
		fmt.Printf("üì¶ Analyzing Package: %s...\n", pkg)
		fmt.Fprintf(f, "\n### Package `%s`\n", pkg)
		
		pkgChunks := pkgGroups[pkg]
		pkgSummary, _ := g.summarizer.SummarizePackage(ctx, pkg, pkgChunks)
		fmt.Fprintf(f, "\n%s\n", pkgSummary)

		// Mermaid Class Diagram for Package
		fmt.Fprintln(f, "\n**Structure**:")
		fmt.Fprintln(f, g.mermaid.GeneratePackageDiagram(pkg, pkgChunks))

		// Constants & Variables Table
		g.generateConfigTable(f, pkgChunks)
	}

	// 6. Core Modules Deep Dive (Development Section)
	fmt.Println("üõ†Ô∏è Generating Development Guide...")
	fmt.Fprintln(f, "\n## Development")
	
	fmt.Fprintln(f, "\n### Core Modules")
	
	// Filter for only significant file modules across all packages
	var modules []knowledge.SearchChunk
	for _, c := range chunks {
		// Only include file modules that are likely core logic (heuristic)
		if c.UnitType == "file_module" && !strings.Contains(c.Name, "test") && !strings.Contains(c.Name, "util") {
			modules = append(modules, c)
		}
	}
	
	// Sort modules
	sort.Slice(modules, func(i, j int) bool {
		return modules[i].Name < modules[j].Name
	})

	for _, mod := range modules {
		fmt.Printf("  - Summarizing module: %s\n", mod.Name)
		fmt.Fprintf(f, "\n#### Module: `%s`\n", mod.Name)
		
		// Use vector search to find related context for this module
		relatedContext, _ := g.engine.SearchRelated(ctx, mod, 3)
		
		analysis, _ := g.summarizer.SummarizeUnit(ctx, mod, "", relatedContext) // CodeBody omitted for token saving, description has enough info
		fmt.Fprintf(f, "%s\n", analysis)
	}

	return nil
}

func (g *MarkdownGenerator) generateGettingStarted(ctx context.Context, f *os.File) {
	fmt.Fprintln(f, "\n## Getting Started")
	// Intent-based retrieval for setup context
	setupContext, _ := g.engine.SearchByText(ctx, "configuration setup main entry point installation guide env variables build run", 10, "")
	guide, _ := g.summarizer.SummarizeGettingStarted(ctx, setupContext)
	fmt.Fprintf(f, "\n### Quick Start\n\n%s\n", guide)
}

func (g *MarkdownGenerator) generateFeatureList(ctx context.Context, f *os.File) {
	fmt.Fprintln(f, "\n## Key Features")
	// Intent-based retrieval for feature context
	featureContext, _ := g.engine.SearchByText(ctx, "core business logic primary features high level architecture use cases", 15, "")
	features, _ := g.summarizer.SummarizeFeatures(ctx, featureContext)
	fmt.Fprintf(f, "\n%s\n", features)
}

func (g *MarkdownGenerator) generateConfigTable(f *os.File, units []knowledge.SearchChunk) {
	var configs []knowledge.SearchChunk
	for _, u := range units {
		if u.UnitType == "constant" || u.UnitType == "variable" {
			configs = append(configs, u)
		}
	}

	if len(configs) == 0 {
		return
	}

	fmt.Fprintln(f, "\n#### ‚öôÔ∏è Constants & Variables")
	fmt.Fprintln(f, "| Name | Type | Value | Description |")
	fmt.Fprintln(f, "| :--- | :--- | :--- | :--- |")

	for _, c := range configs {
		value := "-"
		parts := strings.SplitN(c.Signature, "=", 2)
		if len(parts) == 2 {
			value = strings.TrimSpace(parts[1])
		}
		desc := strings.ReplaceAll(c.Description, "\n", " ")
		fmt.Fprintf(f, "| `%s` | `%s` | `%s` | %s |\n", c.Name, c.UnitType, value, desc)
	}
	fmt.Fprintln(f, "")
}

func isExported(name string) bool {
	if name == "" {
		return false
	}
	first := rune(name[0])
	return unicode.IsUpper(first)
}