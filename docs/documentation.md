# Project Documentation

Auto-generated by `docod`.

## SECTION 1: OVERVIEW & ARCHITECTURE

### High-Level Architecture

This system employs a **Pipeline Architecture**, where data flows sequentially through distinct processing stages. Raw source code is first **crawled**, then **extracted** into a structured format, enriched with semantic understanding via **embedding**, stored and queried in a **knowledge index**, and finally, used to **generate documentation**. This modular design allows for clear separation of concerns and facilitates extensibility with support for new languages or knowledge processing techniques.

### Core Concepts

*   **CodeUnit**: The fundamental building block representing any extracted code symbol (e.g., function, variable, struct, interface). It serves as a universal container for code elements and their metadata.
*   **Relation**: Defines a directed link between `CodeUnit`s, representing dependencies, calls, or other forms of code relationships. These relations are crucial for building the dependency graph.
*   **LanguageExtractor**: An interface defining the contract for language-specific parsers. Each implementation handles the intricacies of a particular programming language to extract `CodeUnit`s and `Relation`s.
*   **Knowledge Engine**: Orchestrates the semantic understanding and retrieval of code information. It leverages embedders to convert code into vector representations and an indexer for efficient search and querying.

### Mermaid Diagram

```mermaid
classDiagram
    direction LR
    class Crawler {
        +ScanProject(path string, callback func(CodeUnit))
        +NewCrawler() Crawler
    }
    class Extractor {
        +NewExtractor(language string) Extractor
        +ExtractFromFile(filePath string) ([]CodeUnit, error)
    }
    class LanguageExtractor {
        <<interface>>
        +GetLanguage() string
        +ExtractUnit(filePath string) ([]CodeUnit, error)
    }
    class GoExtractor {
        +GetLanguage() string
        +ExtractUnit(filePath string) ([]CodeUnit, error)
    }
    class CodeUnit {
        +Symbol string
        +Kind string
        +Content string
        +Relations []Relation
    }
    class Relation {
        +From string
        +To string
        +Type string
    }
    class Graph {
        +AddUnit(unit CodeUnit)
        +LinkRelations()
        +GetDependencies(nodeID string) []Node
        +GetDependents(nodeID string) []Node
    }
    class Node {
        +ID string
        +CodeUnit CodeUnit
    }
    class KnowledgeEngine {
        +NewEngine(embedder Embedder, indexer Indexer) Engine
        +IndexAll()
        +SearchByText(query string) []CodeUnit
        +SearchRelated(chunk SearchChunk) []CodeUnit
    }
    class Embedder {
        <<interface>>
        +Embed(text string) ([]float64, error)
    }
    class GeminiEmbedder {
        +Embed(text string) ([]float64, error)
    }
    class Indexer {
        <<interface>>
        +Add(item VectorItem)
        +Search(query []float64, k int) []VectorItem
        +Save(filePath string) error
        +Load(filePath string) error
    }
    class MemoryIndex {
        +Add(item VectorItem)
        +Search(query []float64, k int) []VectorItem
        +Save(filePath string) error
        +Load(filePath string) error
    }
    class VectorItem {
        +ID string
        +Embedding []float64
        +Content string
    }
    class Summarizer {
        <<interface>>
        +SummarizeFullDoc(chunks []SearchChunk) (string, error)
    }
    class GeminiSummarizer {
        +SummarizeFullDoc(chunks []SearchChunk) (string, error)
    }
    class PromptBuilder {
        +BuildFullDocPrompt(chunks []SearchChunk) string
        +BuildPackagePrompt(chunks []SearchChunk) string
        +BuildUnitPrompt(chunk SearchChunk) string
    }
    class Generator {
        +GenerateDocs() string
    }
    class MarkdownGenerator {
        +GenerateDocs() string
    }
    class MermaidGenerator {
        +GeneratePackageDiagram(chunks []SearchChunk) string
        +GenerateFlowChart(chunks []SearchChunk) string
    }
    class Config {
        +LoadConfig() Config
    }

    Crawler --> CodeUnit : streams
    Extractor --> LanguageExtractor : uses
    Extractor --> CodeUnit : extracts
    GoExtractor --|> LanguageExtractor
    Graph --> Node : manages
    Node --> CodeUnit : contains
    Graph --> Edge : defines
    KnowledgeEngine --> Embedder : uses
    KnowledgeEngine --> Indexer : uses
    KnowledgeEngine --> Summarizer : uses
    KnowledgeEngine --> PromptBuilder : uses
    KnowledgeEngine --> Graph : analyzes
    GeminiEmbedder --|> Embedder
    MemoryIndex --|> Indexer
    GeminiSummarizer --|> Summarizer
    MarkdownGenerator --> Generator : implements
    MermaidGenerator --> Generator : implements
    Config ..> Extractor : configuration
    Config ..> KnowledgeEngine : configuration
```

## SECTION 2: KEY FEATURES

### Code Extraction

*   **Concept**: Automatically parses source code files to identify and extract meaningful code symbols like functions, variables, types, and interfaces. This is the foundational step for understanding the project's structure and content.
*   **Implementation**: The system uses a `Crawler` to traverse the project directory and a language-specific `Extractor`. The `Extractor` utilizes a `LanguageExtractor` (e.g., `GoExtractor` for Go code) to parse individual files. Each `LanguageExtractor` implements the `LanguageExtractor` interface, defining methods to get the language and extract code units. The extracted information is stored as `CodeUnit` structs, which are universal containers for code symbols.
*   **Usage**:
    ```go
    import (
        "your_module_path/extractor"
    )

    // ...

    langExtractor := extractor.NewExtractor("go") // Or other supported languages
    codeUnits, err := langExtractor.ExtractFromFile("path/to/your/file.go")
    if err != nil {
        // Handle error
    }
    for _, unit := range codeUnits {
        // Process each CodeUnit (e.g., print its name and kind)
        fmt.Printf("Extracted: %s (%s)\n", unit.Symbol, unit.Kind)
    }
    ```

### Semantic Indexing and Search

*   **Concept**: Builds a knowledge base of code by converting extracted code units into vector embeddings and storing them in an index. This allows for semantic searching, enabling users to find code snippets based on their meaning rather than exact keywords. It also supports graph-aware searches for related code.
*   **Implementation**: The `KnowledgeEngine` orchestrates this feature. It uses an `Embedder` (like `GeminiEmbedder`) to convert code text into numerical vectors. These `VectorItem`s are then stored in an `Indexer` (like `MemoryIndex`). The `MemoryIndex` provides both vector similarity search and graph proximity search by leveraging the dependency graph information. The `IndexAll` method processes all graph nodes, and `SearchByText` performs semantic search.
*   **Usage**:
    ```go
    import (
        "your_module_path/knowledge"
        // ... other imports
    )

    // Assuming 'engine' is an initialized KnowledgeEngine
    // with a configured Embedder and Indexer.
    // For example:
    // embedder := knowledge.NewGeminiEmbedder("[REDACTED]")
    // indexer := knowledge.NewMemoryIndex(embedder)
    // engine := knowledge.NewEngine(indexer, nil) // Pass graph if available

    searchResults, err := engine.SearchByText("function to parse JSON")
    if err != nil {
        // Handle error
    }
    for _, unit := range searchResults {
        fmt.Printf("Found: %s in %s\n", unit.Symbol, unit.File)
    }
    ```

### Documentation Generation

*   **Concept**: Automatically generates comprehensive documentation in various formats (e.g., Markdown, Mermaid diagrams) from the extracted and indexed code knowledge. This streamlines the documentation process and ensures up-to-date, accurate documentation.
*   **Implementation**: The system provides `MarkdownGenerator` and `MermaidGenerator`. The `MarkdownGenerator`'s `GenerateDocs` method iterates through the project's dependency graph and assembled code units to produce a single Markdown file. The `MermaidGenerator` can create package diagrams and flowcharts using `GeneratePackageDiagram` and `GenerateFlowChart` methods, which take structured code knowledge chunks as input. A `PromptBuilder` is used to construct prompts for LLMs when generating summaries or more complex documentation elements.
*   **Usage**:
    ```go
    import (
        "your_module_path/generator"
        // ... other imports
    )

    // Assuming 'graph' contains the project's dependency graph
    // and 'engine' has indexed the code.

    // Generate Markdown documentation
    mdGenerator := generator.NewMarkdownGenerator()
    markdownDocs, err := mdGenerator.GenerateDocs(graph) // Pass graph or other relevant data
    if err != nil {
        // Handle error
    }
    fmt.Println("--- Markdown Documentation ---")
    fmt.Println(markdownDocs)

    // Generate a Mermaid package diagram (example, requires suitable data)
    // mermaidGen := generator.NewMermaidGenerator()
    // packageDiagram, err := mermaidGen.GeneratePackageDiagram(relevantChunks) // Assuming relevantChunks are prepared
    // if err != nil {
    //     // Handle error
    // }
    // fmt.Println("--- Mermaid Package Diagram ---")
    // fmt.Println(packageDiagram)
    ```

### Hierarchical Summarization

*   **Concept**: Leverages Large Language Models (LLMs) to generate hierarchical summaries of code, providing different levels of detail from individual units to entire packages or the whole document. This aids in quickly understanding complex codebases at various abstraction levels.
*   **Implementation**: The `GeminiSummarizer` implements the `Summarizer` interface, utilizing Google's Gemini Pro. It works in conjunction with the `KnowledgeEngine` and `PromptBuilder`. The `SummarizeFullDoc` method, for instance, likely uses `PromptBuilder` to create context-rich prompts based on extracted code chunks and then sends these to the Gemini API for summarization.
*   **Usage**:
    ```go
    import (
        "your_module_path/knowledge"
        // ... other imports
    )

    // Assuming 'engine' is an initialized KnowledgeEngine
    // and 'knowledgeGraph' is populated.

    // Prepare chunks for summarization (this step might be internal to Engine or explicit)
    // For example:
    // chunks := engine.PrepareSearchChunks(knowledgeGraph.GetAllNodes())

    // Initialize the summarizer
    summarizer := knowledge.NewGeminiSummarizer("[REDACTED]") // Replace with your Gemini API key

    // Summarize the entire document/project
    fullDocSummary, err := summarizer.SummarizeFullDoc(chunks) // 'chunks' should be []knowledge.SearchChunk
    if err != nil {
        // Handle error
    }
    fmt.Println("--- Full Document Summary ---")
    fmt.Println(fullDocSummary)
    ```

## SECTION 3: DEVELOPMENT GUIDE

### Quick Start

**Prerequisites**:

*   Go version 1.18 or higher
*   Access to Google Gemini API (if using Gemini-based embedders/summarizers)

**Run Commands**:

1.  **Clone the repository**:
    ```bash
    git clone <repository_url>
    cd <repository_directory>
    ```

2.  **Install Dependencies**:
    ```bash
    go mod tidy
    ```

3.  **Set Environment Variables**:
    Ensure your Google Gemini API key is set. Refer to the Configuration section for details.

4.  **Build and Run**:
    To run the core logic (e.g., crawling, extracting, indexing, generating docs):
    ```bash
    go run main.go <your_project_path>
    ```
    Replace `<your_project_path>` with the path to the Go project you want to analyze.

### Configuration

Configuration for the system can be managed through environment variables. This allows for flexible deployment and integration into CI/CD pipelines.

*   **`GEMINI_API_KEY`**:
    *   **Description**: This environment variable is required when using the `GeminiEmbedder` or `GeminiSummarizer` to authenticate with the Google Gemini API.
    *   **Usage**: Set this variable before running the application.
    *   **Example**:
        ```bash
        export GEMINI_API_KEY="YOUR_GEMINI_API_KEY"
        go run main.go <your_project_path>
        ```
    *   **Note**: Ensure you replace `"YOUR_GEMINI_API_KEY"` with your actual API key. This key should be treated as a secret and not committed to version control. The code itself will redact this value when logging or displaying configurations.

*   **`CONFIG_PATH` (Optional)**:
    *   **Description**: Specifies a path to a custom configuration file if the system were to support file-based configuration in the future. Currently, environment variables are the primary mechanism.
    *   **Usage**: If implemented, you would set this variable to point to your configuration file.
    *   **Example**:
        ```bash
        export CONFIG_PATH="/path/to/your/config.yaml"
        go run main.go <your_project_path>
        ```
    *   **Note**: As of the provided context, this variable might not be actively used but is included for potential future expansion. The `LoadConfig` function in `config.go` is the entry point for configuration loading.
